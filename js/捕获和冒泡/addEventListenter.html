<!DOCTYPE html>
<html>

<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>

<body>
    <input type="button" value="test1" id="btn1">
    <input type="button" value="test2" id="btn2">
    <div class="div1">
        <div class="div2">好好</div>
    </div>
    <script>
        var fu = document.getElementsByClassName("div1")[0];
        var zi = document.getElementsByClassName("div2")[0];

        //    fu.addEventListener('click',function(){alert("我是父亲")},false);//false 是事件冒泡就是先弹出来的是儿子

        // 最后一个参数不写就是默认的是false
        //    zi.addEventListener('click',function(){alert("我是儿子")},false);




        //true 事件捕获先弹出来的是父亲；
        fu.addEventListener('click', function (e) {
            alert("我是父亲")
            /**
            return false 不仅阻止了事件往上冒泡，而且阻止了事件本身。event.stopPropagation() 则只阻止事件往上冒泡，不阻止事件本身。
            
             stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。
            */
            e.stopPropagation();

        }, true);//


        zi.addEventListener('click', function (e) {
            alert("我是儿子");

        }, true);









 /*
            element.addEventListener(type，handler，false/true)

            type:事件类型

            handler:事件执行触发的函数

            false/true:false为冒泡/ture为捕获，参数是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。

            事件捕获：父级元素先触发，子集元素后触发；

            事件冒泡：子集元素先触发，父级元素后触发；

            一般的绑定事件，都是采用冒泡方式，也就是使用false
             */

    // var btn1=document.getElementById("btn1");/*实名函数*/
    // var count=0;
    // var handle1=function() {
    //     alert(count++);
    //     if (count == 3) {
    //         alert("事件结束")

    //         btn1.removeEventListener("click",handle1,false);
    //     }
    // }
    // btn1.addEventListener('click',handle1,false);


    // var btn2=document.getElementById("btn2");/*匿名函数*/
    // btn2.addEventListener("click",function(){
    //     alert(123);
    //     removeEventListener("click",function(){
    //         alert(123)
    //     },false)
    // },false)

    </script>
</body>

</html>