<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>mutli-promise</title>
</head>
<body>
    <script>
        var val = 1;
 
// 我们假设step1, step2, step3都是ajax调用后端或者是
// 在Node.js上查询数据库的异步操作
// 每个步骤都有对应的失败和成功处理回调
// 需求是这样，step1、step2、step3必须按顺序执行
function step1(resolve, reject) {
    console.log('步骤一：执行');
    if (val >= 1) {
        resolve('Hello I am No.1');// 如果有执行resolve 就还是要有一个判断才行。 resove就是then传过去的
    } else if (val === 0) {
        reject(val);
    }
}
 
function step2(resolve, reject) {
    console.log('步骤二：执行');
    if (val === 1) {
        resolve('Hello I am No.2');
    } else if (val === 0) {
        reject(val);
    }
}
 
function step3(resolve, reject) {
    console.log('步骤三：执行');
    if (val === 1) {
        resolve('Hello I am No.3');
    } else if (val === 0) {
        reject(val);
    }
}
 
new Promise(step1).then(function(val){
    console.info(val);// 这个函数就是resolve() 传过来的
    return new Promise(step2);
}).then(function(val){ // 为什么能连续的then 是因为 返回的是 new Promise();
    console.info(val);
    return new Promise(step3);
}).then(function(val){
    console.info(val);
    return val;
}).then(function(val){
    console.info(val);
    return val;
});
 
// 执行之后将会打印
// 步骤一：执行
// Hello I am No.1
// 步骤二：执行
// Hello I am No.2
// 步骤三：执行
// Hello I am No.3
// Hello I am No.3
    </script>
</body>
</html>