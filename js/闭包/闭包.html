<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

</body>
<script type="text/javascript">
	
// function foo(x) {
//     var tmp = 3;
//     function bar(y) {
//         alert(x + y + (++tmp));
//     }
//     bar(10);
// }
// foo(2)



//	 function a(){
//	 	var i=0;
//	 	function b(){
//	 		alert(++i);
//	 	}
//	 	return b;
//	 }
//
//	 var c=a();//此时的c变量实际上是指向了函数b
//	 c();
	// 	这样在执行完var c=a( )后，变量c实际上是指向了函数b，再执行c( )后就会弹出一个窗口显示i的值（第一次为1）。
// 这段代码其实就创建了一个闭包，为什么？
// 因为函数a外的变量c引用了函数a内的函数b，就是说：
	// 	当函数a的内部函数b被函数a外的一个变量引用的时候，就创建了一个闭包。	　
//
// 　
// function f1(){
// 	var n=999;
// }
// alert(n);
	function f1(){
		var n=999;
		nAdd=function(){n+=1}
		function f2(){
		    n++
			alert(n);
		}
		return f2;
	}
	var result=f1();
	result(); // 999
//	nAdd();
	result(); // 1000
//为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，
//这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中,
//不会在调用结束后，被垃圾回收机制（garbage collection）回收。
//这段代码中另一个值得注意的地方，就是"nAdd=function(){n+=1}"这一行，
//首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。
//其次，nAdd的值是一个匿名函数（anonymous function），
//而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，
//可以在函数外部对函数内部的局部变量进行操作。
//闭包就是能够读取其他函数内部变量的函数。



</script>
</html>